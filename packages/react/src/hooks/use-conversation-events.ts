import type { ConversationEventsState } from "@cossistant/core";
import type {
        GetConversationEventsRequest,
        GetConversationEventsResponse,
} from "@cossistant/types/api/conversation-event";
import { useCallback, useMemo } from "react";
import { useSupport } from "../provider";
import { useStoreSelector } from "./private/store/use-store-selector";
import { useClientQuery } from "./private/use-client-query";

const EMPTY_STATE: ConversationEventsState = {
        events: [],
        hasNextPage: false,
        nextCursor: undefined,
};

const DEFAULT_LIMIT = 50;

export type UseConversationEventsOptions = {
        limit?: number;
        cursor?: string | null;
        enabled?: boolean;
        refetchInterval?: number | false;
        refetchOnWindowFocus?: boolean;
};

export type UseConversationEventsResult = ConversationEventsState & {
        isLoading: boolean;
        error: Error | null;
        refetch: (
                args?: Pick<GetConversationEventsRequest, "cursor" | "limit">
        ) => Promise<GetConversationEventsResponse | undefined>;
        fetchNextPage: () => Promise<GetConversationEventsResponse | undefined>;
};

const NO_CONVERSATION_ID = "__no_conversation__" as const;

export function useConversationEvents(
        conversationId: string | null | undefined,
        options: UseConversationEventsOptions = {}
): UseConversationEventsResult {
        const { client } = useSupport();
        const store = client.eventsStore;

        if (!store) {
                throw new Error("Events store is not available on the client instance");
        }

        const stableConversationId = conversationId ?? NO_CONVERSATION_ID;

        const selection = useStoreSelector(store, (state) => {
                return state.conversations[stableConversationId] ?? EMPTY_STATE;
        });

        const baseArgs = useMemo(() => {
                return {
                        limit: options.limit ?? DEFAULT_LIMIT,
                        cursor: options.cursor ?? undefined,
                } satisfies Pick<GetConversationEventsRequest, "limit" | "cursor">;
        }, [options.cursor, options.limit]);

        const {
                refetch: queryRefetch,
                isLoading: queryLoading,
                error,
        } = useClientQuery<
                GetConversationEventsResponse,
                Pick<GetConversationEventsRequest, "cursor" | "limit">
        >({
                client,
                queryFn: (instance, args) => {
                        if (!conversationId) {
                                return Promise.resolve({
                                        events: [],
                                        hasNextPage: false,
                                        nextCursor: undefined,
                                });
                        }

                        return instance.getConversationEvents({
                                conversationId,
                                limit: args?.limit ?? baseArgs.limit,
                                cursor: args?.cursor ?? baseArgs.cursor,
                        });
                },
                enabled: Boolean(conversationId) && (options.enabled ?? true),
                refetchInterval: options.refetchInterval ?? false,
                refetchOnWindowFocus: options.refetchOnWindowFocus ?? true,
                refetchOnMount: selection.events.length === 0,
                initialArgs: baseArgs,
                dependencies: [
                        stableConversationId,
                        baseArgs.limit,
                        baseArgs.cursor ?? null,
                ],
        });

        const refetch = useCallback(
                (args?: Pick<GetConversationEventsRequest, "cursor" | "limit">) => {
                        if (!conversationId) {
                                return Promise.resolve(undefined);
                        }

                        return queryRefetch({
                                limit: baseArgs.limit,
                                cursor: baseArgs.cursor,
                                ...args,
                        });
                },
                [queryRefetch, baseArgs, conversationId]
        );

        const fetchNextPage = useCallback(() => {
                if (!(selection.hasNextPage && selection.nextCursor)) {
                        return Promise.resolve(undefined);
                }

                return refetch({ cursor: selection.nextCursor });
        }, [selection.hasNextPage, selection.nextCursor, refetch]);

        const isInitialLoad = selection.events.length === 0;
        const isLoading = isInitialLoad ? queryLoading : false;

        return {
                events: selection.events,
                hasNextPage: selection.hasNextPage,
                nextCursor: selection.nextCursor,
                isLoading,
                error,
                refetch,
                fetchNextPage,
        };
}
