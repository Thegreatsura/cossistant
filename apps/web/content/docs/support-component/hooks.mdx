---
title: Hooks
description: Programmatic access to support widget state and visitor management.
---

## Overview

Cossistant provides React hooks for programmatic control over the support widget and visitor identification. These hooks are ideal when you need to integrate support functionality into custom components or respond to application events.

## useSupport

Access support widget state and controls from any client component.

### Basic Example

```tsx showLineNumbers title="components/custom-support-button.tsx"
"use client";

import { useSupport } from "@cossistant/next";

export function CustomSupportButton() {
  const { isOpen, toggle, unreadCount } = useSupport();

  return (
    <button
      onClick={toggle}
      className="relative rounded-lg bg-primary px-4 py-2 text-white"
    >
      Support
      {unreadCount > 0 && (
        <span className="absolute -right-1 -top-1 flex h-5 w-5 items-center justify-center rounded-full bg-red-500 text-xs">
          {unreadCount}
        </span>
      )}
    </button>
  );
}
```

### Return Values

<TypeTable
  variant="return"
  type={{
    website: {
      description: "Website configuration and available agents",
      type: "PublicWebsiteResponse | null",
      typeDescriptionLink: "#publicwebsiteresponse",
      required: true,
    },
    visitor: {
      description: "Current visitor data with normalized locale",
      type: "PublicVisitor & { locale: string | null }",
      typeDescriptionLink: "#publicvisitor",
      required: true,
    },
    isOpen: {
      description: "Whether the support widget is currently open",
      type: "boolean",
      required: true,
    },
    open: {
      description: "Function to open the support widget",
      type: "() => void",
      required: true,
      returns: "void",
    },
    close: {
      description: "Function to close the support widget",
      type: "() => void",
      required: true,
      returns: "void",
    },
    toggle: {
      description: "Function to toggle the widget open/closed state",
      type: "() => void",
      required: true,
      returns: "void",
    },
    unreadCount: {
      description: "Number of unread messages across all conversations",
      type: "number",
      required: true,
    },
    availableHumanAgents: {
      description: "List of human support agents currently available",
      type: "HumanAgent[]",
      typeDescriptionLink: "#humanagent",
      required: true,
    },
    availableAIAgents: {
      description: "List of AI agents configured for support",
      type: "AIAgent[]",
      typeDescriptionLink: "#aiagent",
      required: true,
    },
    client: {
      description: "CossistantClient instance for direct API access",
      type: "CossistantClient",
      typeDescriptionLink: "#cossistantclient",
      required: true,
    },
    isLoading: {
      description: "Whether website data is still loading",
      type: "boolean",
      required: true,
    },
    error: {
      description: "Error object if website data failed to load",
      type: "Error | null",
      required: true,
    },
    size: {
      description: "Widget size configuration",
      type: '"normal" | "larger"',
      required: true,
    },
  }}
/>

## useVisitor

Programmatically identify visitors and manage contact metadata.

<Alert variant="info" className="mt-6 mb-6">
  <Icon name="info" className="size-4" />
  <AlertTitle>Important: Metadata storage</AlertTitle>
  <AlertDescription>
    Metadata is stored on **contacts**, not visitors. You must call `identify()`
    before `setVisitorMetadata()` will work. Learn more about{" "}
    <Link href="/docs/concepts/visitors">visitors</Link> and{" "}
    <Link href="/docs/concepts/contacts">contacts</Link>.
  </AlertDescription>
</Alert>

### Example: Identify on Auth

```tsx showLineNumbers title="components/auth-handler.tsx"
"use client";

import { useVisitor } from "@cossistant/next";
import { useEffect } from "react";

export function AuthHandler({ user }) {
  const { visitor, identify } = useVisitor();

  useEffect(() => {
    // Only identify if we have a user and visitor isn't already a contact
    if (user && !visitor?.contact) {
      identify({
        externalId: user.id,
        email: user.email,
        name: user.name,
        image: user.avatar,
      });
    }
  }, [user, visitor?.contact, identify]);

  return null;
}
```

### Example: Update Metadata on Action

```tsx showLineNumbers title="components/upgrade-button.tsx"
"use client";

import { useVisitor } from "@cossistant/next";

export function UpgradeButton() {
  const { setVisitorMetadata } = useVisitor();

  const handleUpgrade = async () => {
    // Upgrade user's plan
    await upgradeToPro();

    // Update contact metadata so support agents see the change
    await setVisitorMetadata({
      plan: "pro",
      upgradedAt: new Date().toISOString(),
      mrr: 99,
    });
  };

  return <button onClick={handleUpgrade}>Upgrade to Pro</button>;
}
```

### Return Values

<TypeTable
  variant="return"
  type={{
    visitor: {
      description: "Current visitor object (includes contact if identified)",
      type: "PublicVisitor | null",
      typeDescriptionLink: "#publicvisitor",
      required: true,
    },
    identify: {
      description: "Convert anonymous visitor into an identified contact",
      type: "(params: IdentifyParams) => Promise<...>",
      typeDescription:
        "(params: IdentifyParams) => Promise<{ contactId: string; visitorId: string } | null>",
      required: true,
      parameters: [
        {
          name: "params",
          description:
            "Identification parameters including externalId, email, name, image, and metadata. See IdentifyParams type below.",
        },
      ],
      returns:
        "Promise<{ contactId: string; visitorId: string } | null> - Returns the contact and visitor IDs on success, or null on failure",
    },
    setVisitorMetadata: {
      description: "Update metadata for the identified contact",
      type: "(metadata: VisitorMetadata) => Promise<...>",
      typeDescription:
        "(metadata: VisitorMetadata) => Promise<VisitorResponse | null>",
      required: true,
      parameters: [
        {
          name: "metadata",
          description:
            "Metadata object to merge into the contact's existing metadata. See VisitorMetadata type below.",
        },
      ],
      returns:
        "Promise<VisitorResponse | null> - Returns the updated visitor object on success, or null on failure",
    },
  }}
/>

### identify() Parameters

<TypeTable
  variant="parameter"
  type={{
    externalId: {
      description: "Your internal user ID (required if email not provided)",
      type: "string",
      required: false,
    },
    email: {
      description: "User's email address (required if externalId not provided)",
      type: "string",
      required: false,
    },
    name: {
      description: "User's display name",
      type: "string",
      required: false,
    },
    image: {
      description: "URL to user's avatar image",
      type: "string",
      required: false,
    },
    metadata: {
      description: "Initial metadata to attach to the contact",
      type: "VisitorMetadata",
      typeDescription: "Record<string, string | number | boolean | null>",
      typeDescriptionLink: "#visitormetadata",
      required: false,
    },
  }}
/>

<Alert variant="default" className="mt-6">
  <Icon name="lightbulb" className="size-4" />
  <AlertTitle>Prefer declarative code?</AlertTitle>
  <AlertDescription>
    Use the{" "}
    <Link
      href="/docs/support-component#identifying-visitors"
      className="inline-block"
    >
      IdentifySupportVisitor
    </Link>{" "}
    component for a simpler, declarative approach to visitor identification in
    Server Components.
  </AlertDescription>
</Alert>

## Types

### PublicVisitor

The visitor object returned by the widget, representing an anonymous or identified visitor.

<TypeTable
  variant="property"
  type={{
    id: {
      description: "The visitor's unique identifier (ULID)",
      type: "string",
      required: true,
    },
    isBlocked: {
      description: "Whether the visitor is currently blocked from support",
      type: "boolean",
      required: true,
    },
    language: {
      description: "The visitor's preferred language code",
      type: "string | null",
      required: true,
    },
    contact: {
      description:
        "Contact information if the visitor has been identified via identify(). Null for anonymous visitors.",
      type: "PublicContact | null",
      typeDescriptionLink: "#publiccontact",
      required: true,
    },
  }}
/>

### PublicContact

Contact information for an identified visitor.

<TypeTable
  variant="property"
  type={{
    id: {
      description: "The contact's unique identifier (ULID)",
      type: "string",
      required: true,
    },
    name: {
      description: "The contact's display name",
      type: "string | null",
      required: true,
    },
    email: {
      description: "The contact's email address",
      type: "string | null",
      required: true,
    },
    image: {
      description: "URL to the contact's avatar/profile image",
      type: "string | null",
      required: true,
    },
    metadataHash: {
      description: "Hash of the contact's metadata for change detection",
      type: "string",
      required: false,
    },
  }}
/>

### PublicWebsiteResponse

Website configuration and agent availability information.

<TypeTable
  variant="property"
  type={{
    id: {
      description: "The website's unique identifier",
      type: "string",
      required: true,
    },
    name: {
      description: "The website's name",
      type: "string",
      required: true,
    },
    domain: {
      description: "The website's domain",
      type: "string",
      required: true,
    },
    description: {
      description: "The website's description",
      type: "string | null",
      required: true,
    },
    logoUrl: {
      description: "The website's logo URL",
      type: "string | null",
      required: true,
    },
    organizationId: {
      description: "The organization's unique identifier",
      type: "string",
      required: true,
    },
    status: {
      description: "The website's status (active/inactive)",
      type: "string",
      required: true,
    },
    lastOnlineAt: {
      description: "When support was last online",
      type: "string | null",
      required: true,
    },
    availableHumanAgents: {
      description: "List of available human support agents",
      type: "HumanAgent[]",
      typeDescriptionLink: "#humanagent",
      required: true,
    },
    availableAIAgents: {
      description: "List of available AI agents",
      type: "AIAgent[]",
      typeDescriptionLink: "#aiagent",
      required: true,
    },
    visitor: {
      description: "The current visitor information",
      type: "PublicVisitor",
      typeDescriptionLink: "#publicvisitor",
      required: true,
    },
  }}
/>

### HumanAgent

Information about a human support agent.

<TypeTable
  variant="property"
  type={{
    id: {
      description: "The agent's unique identifier",
      type: "string",
      required: true,
    },
    name: {
      description: "The agent's display name",
      type: "string",
      required: true,
    },
    image: {
      description: "URL to the agent's avatar",
      type: "string | null",
      required: true,
    },
    lastSeenAt: {
      description:
        "Timestamp of when the agent was last online. Null or older than 5 minutes means offline.",
      type: "string | null",
      required: true,
    },
  }}
/>

### AIAgent

Information about an AI support agent.

<TypeTable
  variant="property"
  type={{
    id: {
      description: "The AI agent's unique identifier",
      type: "string",
      required: true,
    },
    name: {
      description: "The AI agent's display name",
      type: "string",
      required: true,
    },
    image: {
      description: "URL to the AI agent's avatar",
      type: "string | null",
      required: true,
    },
  }}
/>

### CossistantClient

The underlying client instance for direct API access. Used for advanced programmatic control.

<TypeTable
  variant="property"
  type={{
    conversations: {
      description: "Methods for managing conversations",
      type: "object",
      typeDescription:
        "{ list(), get(id), create(), sendMessage(id, content), markAsRead(id) }",
      required: true,
    },
    visitors: {
      description: "Methods for managing visitor data",
      type: "object",
      typeDescription: "{ identify(params), updateMetadata(metadata) }",
      required: true,
    },
  }}
/>

### IdentifyParams

Parameters for the identify() function.

<TypeTable
  variant="property"
  type={{
    externalId: {
      description: "Your internal user ID (required if email not provided)",
      type: "string",
      required: false,
    },
    email: {
      description: "User's email address (required if externalId not provided)",
      type: "string",
      required: false,
    },
    name: {
      description: "User's display name",
      type: "string",
      required: false,
    },
    image: {
      description: "URL to user's avatar image",
      type: "string",
      required: false,
    },
    metadata: {
      description: "Initial metadata to attach to the contact",
      type: "VisitorMetadata",
      typeDescription: "Record<string, string | number | boolean | null>",
      typeDescriptionLink: "#visitormetadata",
      required: false,
    },
  }}
/>

### VisitorMetadata

Key-value pairs for storing custom data about contacts.

<TypeTable
  variant="property"
  type={{
    "[key: string]": {
      description:
        "Any string key can map to a string, number, boolean, or null value. Common examples include plan, company, role, MRR, etc.",
      type: "string | number | boolean | null",
      required: false,
    },
  }}
/>

**Type Definition:** `Record<string, string | number | boolean | null>`

### SenderType

Enum defining who can send messages.

<TypeTable
  variant="property"
  type={{
    VISITOR: {
      description: "Message from an end user/visitor",
      type: '"visitor"',
      required: true,
    },
    TEAM_MEMBER: {
      description: "Message from a human support agent",
      type: '"team_member"',
      required: true,
    },
    AI: {
      description: "Message from an AI agent",
      type: '"ai"',
      required: true,
    },
  }}
/>

**Type Definition:** `"visitor" | "team_member" | "ai"`
