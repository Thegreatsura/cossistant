---
title: Basic usage
description: Basic usage of the Support component.
---

## Philosophy

The `<Support />` component is built on the principle of **simplicity first**. Drop it into your React app and get a fully functional support system without configuration overhead.

## How it Works

- **Zero Config**: Works out of the box with sensible defaults
- **Progressive Enhancement**: Start simple, customize as needed
- **Real-time Chat**: Built-in WebSocket support for live conversations
- **Smart Routing**: Automatically routes conversations to appropriate channels
- **Headless Architecture**: Full control through primitive components when needed

The component handles the complexity of modern support systems while maintaining a clean, minimal API surface.

## Customizing Messages & Quick Options

Use the `<SupportConfig />` component to customize default messages and quick options per page or route. This is perfect for providing context-specific help.

### Example: Pricing Page

```tsx showLineNumbers title="app/pricing/page.tsx"
import { SupportConfig } from "@cossistant/next";

export default function PricingPage() {
  return (
    <>
      <SupportConfig
        quickOptions={[
          "How does billing work?",
          "What's included in Pro?",
          "Can I cancel anytime?",
        ]}
      />
      <h1>Choose your plan</h1>
      {/* rest of pricing page */}
    </>
  );
}
```

The `<SupportConfig />` component accepts the following props:

<TypeTable
  type={{
    defaultMessages: {
      description: "Custom welcome messages shown before a conversation starts",
      type: "DefaultMessage[]",
      typeDescriptionLink: "#defaultmessage",
      required: false,
    },
    quickOptions: {
      description: "Array of quick reply options displayed to users",
      type: "string[]",
      required: false,
    },
  }}
/>

## Identifying Visitors

By default, visitors are **anonymous**. Use `<IdentifySupportVisitor />` to connect them to your authenticated users, transforming them into [contacts](/docs/concepts/contacts).

Once identified, all conversations and metadata are linked to the contact across devices.

### Example: Dashboard Layout with Better Auth

```tsx showLineNumbers title="app/dashboard/layout.tsx"
import { IdentifySupportVisitor } from "@cossistant/next";
import { auth } from "@/lib/auth";
import { headers } from "next/headers";

export default async function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const session = await auth.api.getSession({
    headers: await headers(),
  });

  return (
    <div>
      {session?.user && (
        <IdentifySupportVisitor
          externalId={session.user.id}
          email={session.user.email}
          name={session.user.name}
          image={session.user.image}
          metadata={{
            plan: session.user.plan,
            signupDate: session.user.createdAt,
          }}
        />
      )}
      {children}
    </div>
  );
}
```

<Alert variant="info" className="mt-6">
  <Icon name="help" className="size-4" />
  <AlertTitle>What happens when I identify a visitor?</AlertTitle>
  <AlertDescription>
    The anonymous visitor becomes associated with a contact. All their
    conversations, metadata, and future interactions are linked to this
    contact—even across different devices. Learn more about{" "}
    <Link href="/docs/concepts/visitors">visitors</Link> and{" "}
    <Link href="/docs/concepts/contacts">contacts</Link>.
  </AlertDescription>
</Alert>

### Props

<TypeTable
  type={{
    externalId: {
      description: "Your internal user ID to uniquely identify this visitor",
      type: "string",
      required: false,
    },
    email: {
      description: "User's email address (required if externalId not provided)",
      type: "string",
      required: false,
    },
    name: {
      description: "User's display name shown in conversations",
      type: "string | null",
      required: false,
    },
    image: {
      description: "URL to user's avatar image",
      type: "string | null",
      required: false,
    },
    metadata: {
      description:
        "Additional context about the user (plan, company, MRR, etc.)",
      type: "VisitorMetadata | null",
      typeDescription: "Record<string, string | number | boolean | null>",
      typeDescriptionLink: "#visitormetadata",
      required: false,
    },
  }}
/>

<Alert variant="default" className="mt-6">
  <Icon name="code" className="size-4" />
  <AlertTitle>Need programmatic control?</AlertTitle>
  <AlertDescription>
    Use the{" "}
    <Link href="/docs/support-component/hooks#usevisitor">useVisitor</Link> hook
    to identify visitors or update metadata from client components.
  </AlertDescription>
</Alert>

## Support Component Props

The `<Support />` component accepts these optional props to customize its appearance and behavior:

<TypeTable
  type={{
    className: {
      description: "Additional CSS classes for the support widget container",
      type: "string",
      required: false,
    },
    position: {
      description: "Vertical position of the widget",
      type: '"top" | "bottom"',
      default: '"bottom"',
      required: false,
    },
    align: {
      description: "Horizontal alignment of the widget",
      type: '"right" | "left"',
      default: '"right"',
      required: false,
    },
    positioning: {
      description: "CSS positioning strategy for the widget",
      type: '"fixed" | "absolute"',
      default: '"fixed"',
      required: false,
    },
    theme: {
      description:
        "Force a specific theme (light/dark). Omit for automatic detection",
      type: '"light" | "dark"',
      required: false,
    },
    slots: {
      description:
        "Replace core components (bubble, container, router) with custom implementations",
      type: "object",
      typeDescription:
        "{ bubble?: ComponentType<BubbleSlotProps>, container?: ComponentType<ContainerSlotProps>, router?: ComponentType<RouterSlotProps> }",
      required: false,
    },
    classNames: {
      description:
        "Granular className overrides for specific parts of the widget",
      type: "object",
      typeDescription: "{ root?: string, bubble?: string, container?: string }",
      required: false,
    },
    children: {
      description: "Declarative Page components to register custom routes",
      type: "React.ReactNode",
      required: false,
    },
    quickOptions: {
      description: "Quick reply options for this specific widget instance",
      type: "string[]",
      required: false,
    },
    defaultMessages: {
      description: "Welcome messages shown before conversation starts",
      type: "DefaultMessage[]",
      typeDescriptionLink: "#defaultmessage",
      required: false,
    },
    defaultOpen: {
      description: "Whether the widget should open automatically on mount",
      type: "boolean",
      required: false,
    },
    locale: {
      description:
        "Locale string for widget translations (e.g., 'en', 'fr', 'es')",
      type: "string",
      required: false,
    },
    content: {
      description: "Custom text content overrides for widget copy",
      type: "Partial<SupportTextContent>",
      typeDescription:
        "Partial record of all text strings used in the widget for internationalization and customization",
      required: false,
    },
  }}
/>

### Usage Examples

Basic customization with theme and styling:

```tsx
<Support
  theme="dark"
  position="bottom"
  align="right"
  classNames={{
    bubble: "bg-purple-600 hover:bg-purple-700",
    container: "border-purple-200 shadow-2xl",
  }}
/>
```

With custom page:

```tsx
import { Support, Page, useSupportNavigation } from "@cossistant/next";

const HelpPage = () => {
  const { goBack } = useSupportNavigation();
  return (
    <div className="p-4">
      <button onClick={goBack}>← Back</button>
      <h1>Help Center</h1>
    </div>
  );
};

export default function App() {
  return (
    <Support>
      <Page name="HELP" component={HelpPage} />
    </Support>
  );
}
```

For advanced customization, see the [Custom Components](/docs/support-component/custom-components) guide.

## Types

### DefaultMessage

Structure for pre-conversation welcome messages.

<TypeTable
  variant="property"
  type={{
    content: {
      description: "The message text content",
      type: "string",
      required: true,
    },
    senderType: {
      description: "Who is sending the message",
      type: "SenderType",
      typeDescription: '"visitor" | "team_member" | "ai"',
      typeDescriptionLink: "#sendertype",
      required: true,
    },
    senderId: {
      description: "Optional ID of the specific sender (agent or AI)",
      type: "string",
      required: false,
    },
  }}
/>

### VisitorMetadata

Key-value pairs for storing custom data about contacts.

<TypeTable
  variant="property"
  type={{
    "[key: string]": {
      description:
        "Any string key can map to a string, number, boolean, or null value. Common examples include plan, company, role, MRR, etc.",
      type: "string | number | boolean | null",
      required: false,
    },
  }}
/>

**Type Definition:** `Record<string, string | number | boolean | null>`

### SenderType

Enum defining who can send messages.

<TypeTable
  variant="property"
  type={{
    VISITOR: {
      description: "Message from an end user/visitor",
      type: '"visitor"',
      required: true,
    },
    TEAM_MEMBER: {
      description: "Message from a human support agent",
      type: '"team_member"',
      required: true,
    },
    AI: {
      description: "Message from an AI agent",
      type: '"ai"',
      required: true,
    },
  }}
/>

**Type Definition:** `"visitor" | "team_member" | "ai"`
